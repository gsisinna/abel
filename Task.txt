--- FASE 1 : CONTROLLO DI UN SINGOLO servo DYNAMIXEL TRAMITE ROS ---

1.1 - Consultare documentazione ufficiale ROS + Dinamixel (http://wiki.ros.org/dynamixel) (https://emanual.robotis.com/docs/en/software/dynamixel/dynamixel_sdk/overview/#supported-dynamixels)

1.2 - Datasheets motori Abel: valori di riferimento e protocollo di comunicazione

1.3 - Creazione package ros, listener.py, talker.py, launch file e msgs (tipi di dati coinvolti). 

1.4 - Creare repository Github per tenere traccia delle versioni del codice (https://github.com/gsisinna/abel)

1.5 - Connessione board (https://emanual.robotis.com/docs/en/parts/interface/u2d2/)

1.6 - Dynamixel Controllers (meta-controller, position control, torque control)

1.7 - Testing e debugging 



--- FASE 2: CONTROLLO DI PIÙ MOTORI. INIZIARE CON DUE E SUCCESSIVAMENTE UN SOLO BRACCIO (NO COLLISIONI) ---

2.1 - Connessione servo in configurazione daisy chain, pacchetti per comunicazione e script/files ROS multi-joint

2.2 - Dual joint position controller (http://wiki.ros.org/dynamixel_controllers/Tutorials/Creating%20a%20dual%20joint%20position)

2.3 - Tuning parametri controllore (velocità max, torque e range di sicurezza)

2.4 - Riuscire a mantenere braccio disteso (frontalmente) e modulare velocità

2.5 - Test e debugging per diverse posizioni (o gestualità)



--- FASE 3: CINEMATICA DIRETTA ---

3.1 - Risalire alla mappa cinematica diretta (Denavit-Hartenberg, CAD files, URDF?)

Nota: avere un CAD file, e poter lavorare con un URDF permetterebbe di simulare il braccio su Gazebo, oltre che utilizzare la 
Rigid Body Dynamics Library (RBDL), utilissima per la cinematica diretta ed inversa.


--- FASE 4: COMPLIANCE CONTROL. REALIZZARE UN CONTROLLO "SOFT" E HUMAN LIKE PER IL MOVIMENTO DEL BRACCIO.

Nota: Preferisco inserire questo step prima del controllo bimanuale in modo da lavorare in sicurezza per quanto riguarda le possibili collisioni,
che devono essere evitate o in caso estremo non produrre danni grazie alla compliance del controllo realizzato. Un consiglio da parte del lab di robotica potrebbe essere molto utile in questa fase per la realizzazione del controllo più adeguato (impedenza virtuale, compliance, torque ecc... )

4.1 - Studio teoria riguardante il controllo scelto (equazioni)

4.2 - Implementazione su ROS + Python ed integrazione con precedenti versioni del codice

4.3 - Gestures primitive per movimento human-like (stretta di mano, saluto ecc...)

4.4 - Testing e valutazione risultati



--- FASE 5: CINEMATICA INVERSA. DATO UN PUNTO (PER SINGOLO BRACCIO?) NEL WORKSPACE RAGGIUNGIBILE DEL ROBOT VOGLIAMO CHE ABEL LO RAGGIUNGA NEL MODO PIÙ "UMANO" POSSIBILE

5.1 - Closed Loop Inverse Kinematics (CLIK) --> Approccio corretto? Singolarità, Jacobiano e limiti del modello. Approccio geometrico?

5.2 - Testing di diversi modelli



--- FASE 6: CONTROLLO BIMANUALE IN WORKSPACE RAGGIUNGIBILE, SENZA COLLISSIONI ---

Da definire in base ai risultati precedenti.



